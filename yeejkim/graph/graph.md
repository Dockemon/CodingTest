# 👣 탐색 (Search)
- 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정 
- 대표적인 탐색 알고리즘 → DFS, BFS 

## 🛣️ DFS 
- Depth-First Search (깊이 우선 탐색)
- 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘 

- ⇒ 가장 깊은 노드까지 탐색한 후, 더 이상 탐색할 수 없을 때 이전 노드로 돌아가며 다시 탐색을 반복하는 방식

- Stack 이용 
- 실제 구현에서는 **재귀 함수** 통해 스택 동작 대체 가능

- 동작 과정 
    <br> 1. 탐색 시작 노드를 스택에 삽입, **방문 처리** 진행
    <br> 2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있다면 그 인접 노드를 스택에 넣고 방문 처리 
    <br> 3. 2번의 과정을 수행할 수 없을 때까지 반복 


- 데이터 개수 N개인 경우, O(N) 시간 소요

<br>


> **Graph**
> - Node, Edge(간선)로 구성
> - Graph Search란, 하나의 노드를 시작으로 다수의 노드를 방문하는 것 
> - 두 노드가 간선으로 연결되어 있다 → 두 노드는 **인접**하다 표현

> **인접 행렬**
> - 2차원 배열에 각 노드가 연결된 형식을 기록하는 방식 
> - Python에서는 2차원 리스트로 구현 
> - 모든 정점 쌍의 연결 여부 저장 
> - 모든 관계를 저장하기에, 메모리 사용량이 크지만, 연결 여부 빠르게 확인 가능

> **인접 리스트**
> - 리스트로 그래프의 연결 관계를 표현하는 방식 
> - 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장
> - 기본 자료형 리스트에 ```append()```와 같은 메소드 사용하여 연결 
> - 2차원 리스트로 구현
> - 각 정점의 이웃 정점 저장 (연결된 정보만 저장)
> - 메모리 사용량이 적고, 연결된 정점을 순회하는 데 유리

<br>


| 구조     | 장점                  | 단점                 |
| ------ | ------------------- | ------------------ |
| 인접 행렬  | 연결 여부 빠르게 확인 (O(1)) | 메모리 많이 사용 (O(V²))  |
| 인접 리스트 | 메모리 효율적 (O(V+E))    | 연결 여부 확인 느림 (O(V)) |





## 🌳 BFS 
- Breadth First Search
- 가까운 노드부터 탐색하는 알고리즘
- DFS는 한 방향으로 깊게 들어가며 탐색하지만, BFS는 **넓게 퍼지듯** 가까운 노드부터 탐색
- queue 자료구조 이용 
- 동작 과정 
<br> 1. 탐색 시작 노드를 큐에 삽입하고 방문 처리
<br> 2. 큐에서 노드 꺼내, 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입 & 방문 처리 
<br> 3. 2번 과정을 더 이상 수행할 수 없을 때까지 반복 


- deque 라이브러리 사용 
- O(N) 시간 소요
- 그래프 구조에 따라 DFS보다 효율적일 수 있음 