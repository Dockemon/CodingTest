# 🔙 백트래킹 (Backtracking)

## 📌 정의
- **모든 경우의 수를 고려**하여 해답을 찾는 **완전 탐색** 기반 알고리즘
- 해가 될 수 없는 후보를 중간에 **포기하고 되돌아감**으로써 불필요한 탐색 줄이기
- **재귀 호출**을 이용해 문제를 단계적으로 해결하며, 유망하지 않은 해는 탐색하지 않음

<br>

## ⚙️ 핵심 개념
- 모든 경우를 시도하면서 해답을 찾되, 도중에 **조건을 만족하지 않으면 가지치기(pruning)** 수행
- 대표적으로 **DFS** 또는 **BFS** 사용

<br>

## 🧠 사용 알고리즘

- **깊이 우선 탐색 (DFS)**
    - 트리에서 바닥에 도달할 때까지 한쪽 방향으로만 내려가는 방식 
    - 재귀함수를 사용하여 목표한 바가 나올 때까지 반복
    - 일반적으로 모든 경우의 수를 고려해야 할 때는 DFS가 편리 
    - 단, 루프가 있거나 분기점 없이 긴 길이 있다면 불리
    
- **너비 우선 검색 (BFS)**
    - 모든 분기점을 다 검사하면서 진행하는 방식
    - queue를 사용하여, queue에 넣고 검사한 원소를 제거 
    - DFS의 단점을 개선하기 위해 최단 거리 구하기에서 사용하면 좋음 

- **최선 우선 탐색**
    - 우선순위 큐를 사용하여 구현하며, 가장 효율적인 방법
    - 무의미한 탐색을 막기 위한 가지치기(Bounded function) 있을 경우 성능 향상

<br>

## ⏱️ 시간 복잡도

| 유형 | 설명 | 시간복잡도 |
|------|------|-------------|
| 중복 허용 | 예: 중복 숫자 선택 허용 | `N^k` |
| 중복 불가 | 예: 서로 다른 숫자 선택 | `N!` |
| N-Queen 등 | 각 상황마다 다름 | 일반적으로 **지수 시간** |

> ⚠️ 백트래킹은 경우의 수를 줄이지만, **최악의 경우 여전히 많은 시간**이 소요될 수 있음

<br>

## 🧩 문제 유형

- N-Queen
- 부분 집합 구하기
- 순열(Permutation)
- 조합(Combination)
- 암호 만들기
- 사다리 조작
- 스도쿠


<br>


## 📝 기본 코드 템플릿 (Python)

- **선택 → 탐색 → 복구(되돌리기)**

```python
def backtrack(depth):
    if depth == 목표깊이:
        # 정답 조건에 맞는 경우 처리
        return

    for i in range(시작값, 끝값):
        if 조건에 맞지 않으면: # 유망하지 않으면
            continue

        # 상태 선택
        선택된_값_저장.append(i)

        # 재귀 호출 (다음 단계 진행)
        backtrack(depth + 1)

        # 상태 복구 (선택 되돌리기)
        선택된_값_저장.pop()
